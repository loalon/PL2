package compiler.syntax;

// Declaraci칩n de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

//Imports usuario
import java.util.Map.Entry;

// DeclaraciOn del cOdigo de usuario

action code   {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();
:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	ScopeManagerIF     scopeManager       = CompilerContext.getScopeManager ();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
	

:}

// DeclaraciOn de terminales

terminal Token CONSTANT;
terminal Token MINUS;
terminal Token ELSE;
terminal Token FOR;
terminal Token IF;
terminal Token INT;
terminal Token MAIN;
terminal Token PRINTC;
terminal Token PRINTI;
terminal Token RETURN;
terminal Token STRUCT;
terminal Token VOID;
terminal Token ID;
terminal Token NUM;
terminal Token ASSIGMENT;
terminal Token SEMICOLON;
terminal Token OBRACKET;
terminal Token CBRACKET;
terminal Token OBRACE;
terminal Token CBRACE;
terminal Token POINT;
terminal Token EQUAL;
terminal Token MORE;
terminal Token OR;
terminal Token COMMA;
terminal Token TCHAIN;


// Declaracion de no terminales
// no modificar los propuestos

non terminal	program;
non terminal AxiomNT		axiom;

non terminal Constante constanteS;
non terminal Constante constante;
non terminal 	decconstantes;

non terminal	Tipo	tipo;
non terminal	Camporeg	camporeg;
non terminal	CamporegB	camporegB;
non terminal	ArrayList<String>	camporegC;
non terminal 	ArrayList<Tipo>	dectipos;

non terminal	VariableA variable;
non terminal	VariableA	variableA;
non terminal	VariableB	variableB;
non terminal	VariableC	variableC;
non terminal	NonTerminalGeneric	decvariables;

non terminal	ExpLog	expLog;
non terminal	String	operador;
non terminal	Expresion	expAsig;
non terminal	ExpAcceso	expAcceso;
non terminal	Expresion	expresion;

non terminal	InvFunc	invFunc;
non terminal	InvFuncA	invFuncA;

non terminal	Funcion    funcion;
non terminal	FuncionA funcionA;
non terminal	ArrayList<Tipo>	funcionB;
non terminal	NonTerminalGeneric	funcionC;
non terminal	FuncionD	funcionD;
non terminal	FuncionE	funcionE;
non terminal	FuncionS	funcionS;
non terminal	NonTerminalGeneric	decfunciones;

non terminal	NonTerminalGeneric	main;
non terminal	NonTerminalGeneric	mainA;
non terminal	NonTerminalGeneric	mainB;
non terminal	NonTerminalGeneric	mainC;
non terminal	NonTerminalGeneric	mainD;

non terminal 	NonTerminalGeneric	sentFor;
non terminal	SentForA	sentForA;
non terminal	Sentencia	sentSalida;
non terminal	Sentencia	sentEntrada;
non terminal	Sentencia	sentencia;
non terminal	NonTerminalGeneric	bloqueSent;
non terminal	ArrayList<Tipo>	tiposLocales;
non terminal	NonTerminalGeneric	variablesLocales;
non terminal	NonTerminalGeneric	sentLocales;
non terminal	Sent_if	sent_if;

// Declaracion de relaciones de precedencia
precedence right	ASSIGMENT;
precedence left		OR;
precedence left		EQUAL;
precedence left 	MORE;
precedence left		MINUS;
precedence left     POINT, OBRACKET, CBRACKET;
precedence nonassoc ELSE, IF, ID;

// Declaracion de reglas de produccion


start with program;

program ::= 
{: 
	syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
	scopeManager.openScope();
:}  axiom:ax
{: 
	int gAddress = 2; //la primera instruccion de salto ocupa 2
	int stringsSize = 0;
	List<ScopeIF> scopes = scopeManager.getAllScopes(); 

	for (ScopeIF scope: scopes) {
		int lOffset=0; 
		List<SymbolIF> symbols = scope.getSymbolTable ().getSymbols(); 
		for (SymbolIF simbolo: symbols) {
			if (simbolo instanceof SymbolConstantString) {
				SymbolConstantString s = (SymbolConstantString) simbolo;
				stringsSize+=s.getSize();
				//continue; //ignora los string al asignar direcciones
			}
			else if (simbolo instanceof SymbolVariable) {
				SymbolVariable s = (SymbolVariable) simbolo;
				//if (s.getType() instanceof TypeString){

				//}
				if (scope.getLevel () == 0) { //solo para var globales
					s.setAddress (gAddress);
					gAddress += s.getType().getSize(); //coge el tama絪 de la var, lo suma 
				} else { //si no son globales, direccion con respecto al puntero PILA
					s.setAddress (lOffset);
					lOffset = lOffset + s.getType().getSize(); 
				} 
			}
		} 
		lOffset=0; //reinicio el contador
		List<TemporalIF> temporales = scope.getTemporalTable ().getTemporals(); 
		//System.out.println(temporales);
		for (TemporalIF temp: temporales) { //los temporales son respecto puntero del monton 
			Temporal t = (Temporal) temp;
			System.out.println(t.getName());
			System.out.println(t.getScope());
			t.setAddress (lOffset); //+ t.getSize());
			lOffset += t.getSize();
		}
	}

	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	
	cb.addQuadruple("BR", new Value(gAddress+stringsSize)); //la primera instruccion estara
	cb.addQuadruple("ORG", new Value(gAddress)); //reservo espacio para variables con MACROINSTRUCCION DATA
	for (ScopeIF s: scopes) { //inserta los textos como espacio dentro de variables globales 
		for (SymbolIF symbol: s.getSymbolTable ().getSymbols()) {
			//if (symbol instanceof SymbolVariable && symbol.getType() instanceof TypeString) {
			if (symbol instanceof SymbolConstantString) {
				SymbolConstantString symbolS = (SymbolConstantString) symbol;// .getType();
				cb.addQuadruple("TEXT", new Value (symbolS.getName()), new Value(symbolS.getValue()));
			}
		}
	}
	
	LabelFactory lf = new LabelFactory();
	LabelIF label = lf.create();
	cb.addQuadruple("BR", label); // debe ir directo a main
	//cb.addQuadruple("BR", label); // debe ir directo a main
	LabelIF labelGlobal = new LabelFactory().create("L_GLOBAL");
	//IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruple("INL",labelGlobal); // uno por funcion, para test
	cb.addQuadruples(ax.getIntermediateCode()); //todo el codigo
	
	cb.addQuadruple("HALT"); //ultima instruccion del programa
	cb.addQuadruple("INL", label); // etiqueta HALT desde aqui son dos pasos mas hasta el fin de zona codigo
	cb.addQuadruple("START", new Value(gAddress+stringsSize)); // instrucciones al arrancar, le paso tama絪 global y strings
	cb.addQuadruple("BR", new Value("L_L_GLOBAL")); // debe ir directo a main
	ax.setIntermediateCode(cb.create());
	
	for(QuadrupleIF code : ax.getIntermediateCode ()) 
		semanticErrorManager.semanticDebug( code.toString() + "\n");
  
  		// No modificar esta estructura, aunque se pueden a침adir m치s acciones sem치nticas
  		// Las dos siguientes lineas son para cuando acabe la practica		
  		List intermediateCode = ax.getIntermediateCode ();
  		finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no est치 completo. Esto es debido a que 
  		// a칰n no se tendr치 implementada la generaci칩n de c칩digo intermedio ni final.
  		// Para la entrega final deber치n descomentarse y usarse.
	scopeManager.closeScope();
	syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  :};


axiom ::= decconstantes:dec dectipos:det decvariables:dev decfunciones:def
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	TypeTableIF tTable = scope.getTypeTable();
	AxiomNT ax = new AxiomNT();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);

	cb.addQuadruples(dev.getIntermediateCode()); //activar al final 
		cb.addQuadruple("BR", new Value("L_MAIN")); // debe ir directo a main
	cb.addQuadruples(def.getIntermediateCode()); //OK
	ax.setIntermediateCode(cb.create());
	RESULT= ax;
:};

decconstantes ::= constanteS:css decconstantes:dcc 
{:
	String name = css.getName();
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF sTable = scope.getSymbolTable ();
	
	if (sTable.containsSymbol(name))
		semanticErrorManager.semanticFatalError("Constante: "+name+" duplicada");

	SymbolConstant sc = new SymbolConstant(scope, name, new TypeSimpleInteger(scope), css.getValue()); 
	sTable.addSymbol(name, sc);
	
:} | {:

:} ;

dectipos ::= tipo:tp dectipos:dct 
{:
	dct.add(tp);
	RESULT=dct;
:} | {:	RESULT=new ArrayList<Tipo>(); :};

decvariables ::= decvariables:dec variable:var
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
//WIP quizas tenga que alterar el orden del CI	
	cb.addQuadruples(dec.getIntermediateCode());
	cb.addQuadruples(var.getIntermediateCode());
	System.out.println("En global");
	System.out.println(var.getIntermediateCode());
	dec.setIntermediateCode(cb.create());
	RESULT=dec;
:} | {:
	NonTerminalGeneric dec = new NonTerminalGeneric();
	RESULT= dec;
:};

decfunciones ::= funcion:f decfunciones:df
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	NonTerminalGeneric dec = new NonTerminalGeneric();	
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruples(f.getIntermediateCode()); //codigo de la esta funcion
	cb.addQuadruples(df.getIntermediateCode()); //codigo de las demas funciones
	dec.setIntermediateCode(cb.create());
		System.out.println("En dec funciones TOTAL");
	System.out.println(dec.getIntermediateCode());
	RESULT= dec;
:}
 |  main:m 
{:
	NonTerminalGeneric dec = new NonTerminalGeneric();
	dec.setIntermediateCode(m.getIntermediateCode()); //codigo de main
	RESULT= dec;
:};

/************************************
//Declaracion de constantes
************************************/
constanteS ::= CONSTANT constante:c
{:	RESULT=c;  :};

constante ::= ID:id NUM:n SEMICOLON
{:
	Integer value = new Integer(Integer.valueOf(n.getLexema()));
	String nombre = new String (id.getLexema());
	Constante c =new Constante(nombre, value);
	RESULT=c;
:}; 


/************************************
//Declaracion de tipo Registro
************************************/

tipo ::= STRUCT ID:id OBRACE 
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	scopeManager.openScope(id.getLexema()); //creo el scope del registro

:} camporeg:creg CBRACE {: //cargo datos registro
	String name = id.getLexema();
	scopeManager.closeScope(); //cierro el scope
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF sTable = scope.getSymbolTable();
	TypeTableIF tTable = scope.getTypeTable();
	
	TypeIF type = new TypeRecord(scope, name, creg.getSize(), creg.getOffsetMap()); //guarda tama絪 y tabla de desplazamientos
	
	if(tTable.containsType(type)) 
		semanticErrorManager.semanticFatalError("Tipo registro: "+name+" duplicado");
				
	tTable.addType(name, type);
	RESULT= new Tipo(name, type);

:};
 
camporeg ::= camporegB:crb  //una lsita
{:
	ScopeIF scope = scopeManager.getCurrentScope(); //scope dentro de registro
	SymbolTableIF sTable = scope.getSymbolTable();
	TypeIF tipo = crb.getType();
	
	Camporeg cr= new Camporeg();
	ArrayList<String> lista = crb.getVariables();
	for (String name : lista) {
		
		if(sTable.containsSymbol(name))
			semanticErrorManager.semanticFatalError("Variable : "+name+" ya esta registrada en este registro "); // + id.getLine() + id.getColumn());
		sTable.addSymbol(name, new SymbolVariable(scope, name, tipo ));
		if (tipo instanceof TypeSimpleInteger)
			cr.add(name, 1);
		else if (tipo instanceof TypeRecord)
			cr.add(name, tipo.getSize());
	}	
	RESULT=cr;
:}			
| camporeg:cr camporegB:crb //varias listas
{:
	ScopeIF scope = scopeManager.getCurrentScope(); //scope dentro de registro
	SymbolTableIF sTable = scope.getSymbolTable();
	TypeIF tipo =crb.getType();
	ArrayList<String> lista = crb.getVariables();
	for (String name : lista) {
		
		if(sTable.containsSymbol(name))
			semanticErrorManager.semanticFatalError("Variable : "+name+" ya esta registrada en este registro "); // + id.getLine() + id.getColumn());
		sTable.addSymbol(name, new SymbolVariable(scope, name, tipo ));
		if (tipo instanceof TypeSimpleInteger)
			cr.add(name, 1);
		else if (tipo instanceof TypeRecord)
			cr.add(name, tipo.getSize());
	}	
	RESULT=cr;

:};

camporegB ::= INT ID:id SEMICOLON  //solo un int
{:
	String name = id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();
	CamporegB cr = new CamporegB(name, new TypeSimpleInteger(scope)); //entra 
	RESULT=cr;	
:}
| ID:idTipo ID:id SEMICOLON //solo un record
{:
	String name = id.getLexema();
		String nameTipo = idTipo.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	TypeIF tipo = scopeManager.searchType(nameTipo);
	if(tipo==null) 
		semanticErrorManager.semanticFatalError("El tipo: "+name+" no esta declarado en el ambito global"+" Linea: " +id.getLine() +" Columna: "+ id.getColumn()); 

	CamporegB cb = new CamporegB(name, tipo); //entra 
	RESULT=cb;	
:}
| INT ID:id camporegC:cr	//multiples id
{:
	String name = id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF sTable = scope.getSymbolTable();	

	CamporegB cb = new CamporegB(name,new TypeSimpleInteger(scope),cr); //entra 
	RESULT=cb;	
:}	
| ID:idTipo ID:id camporegC:cr // tipo struct dos o varios
{:
	String name = id.getLexema();
	String nameTipo = idTipo.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	TypeIF tipo = scopeManager.searchType(nameTipo);
	if(tipo==null) 
		semanticErrorManager.semanticFatalError("El tipo: "+name+" no esta declarado en el ambito global"+" Linea: " +id.getLine() +" Columna: "+ id.getColumn()); 
	
	CamporegB cb = new CamporegB(name, tipo, cr); //entra 
	RESULT=cb;	
:};
 			
camporegC ::= COMMA ID:id camporegC:cr //nombres y comas
{:
	String name = id.getLexema();
	cr.add(name);  
	RESULT=cr;	
:}
| COMMA ID:id SEMICOLON 
{:
	String name = id.getLexema();
	ArrayList<String> cr = new ArrayList<String>();
	cr.add(name);
	RESULT=cr;	
:};

/************************************
//Declaracion de variables
************************************/
variable ::= ID:id variableA:va  //aqui el tipo personalizado se compara con lo que arrastro
{:
	String name = id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope(); //en el que estoy
	SymbolTableIF sTable = scope.getSymbolTable();
	TypeIF type = va.getType(); //el tipo de la variable
	
	List<ScopeIF> listScope = scopeManager.getOpenScopes();
	ScopeIF scopeX= null; //scope del tipo declarado
	for (ScopeIF sco: listScope){//reviso lista de scopes abiertos
		TypeTableIF tempTable=sco.getTypeTable();
		if(tempTable.containsType(id.getLexema())){
			scopeX=sco;
			break;
		}
	}
	if(scopeX==null)
		semanticErrorManager.semanticFatalError("AMBITO NO ENCONTRADO." +" Linea: " +id.getLine() +" Columna: "+ id.getColumn());
	
	TypeTableIF tTableX = scopeX.getTypeTable();

	//if(!tTableX.containsType(id.getLexema()))
		//semanticErrorManager.semanticFatalError(""+name+" no es un tipo declarado." +" Linea: " +id.getLine() +" Columna: "+ id.getColumn());		
	
	TypeIF tipoDeclarado =tTableX.getType(id.getLexema());

	if (type == null || ( type != null && type.equals(tipoDeclarado) ) ) { //tipo correcto
		ArrayList<String> lista = va.getVariables();
		type=tipoDeclarado;
		for(String s : lista) {
			if(sTable.containsSymbol(s))
				semanticErrorManager.semanticFatalError("El nombre : "+s+" duplicado" + id.getLine() + id.getColumn());
			sTable.addSymbol(s, new SymbolVariable(scope, s, tipoDeclarado))		;	
		}
	} else
		semanticErrorManager.semanticFatalError("ERROR123");
	va.setType(type);
	va.addVariable(name);		
	RESULT= va;	
:}
| INT:id variableA:va //aqui el tipo int, compara con lo arrastrado
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF sTable = scope.getSymbolTable();
	TypeTableIF tTable = scope.getTypeTable();
	TypeIF type = va.getType();
	String name = new String(id.getLexema());
	
	if (type == null || type instanceof TypeSimpleInteger) { //tipo correcto
		ArrayList<String> lista = va.getVariables();
				//type=new TypeSimpleInteger(scope);
		for(String s : lista) {
			if(sTable.containsSymbol(s))
				semanticErrorManager.semanticFatalError("El nombre INT : "+s+" duplicado" + id.getLine() + id.getColumn());
			type =new TypeSimpleInteger(scope);
			sTable.addSymbol(s,new SymbolVariable(scope, s, type ));		
		}
	} else {
		semanticErrorManager.semanticFatalError("ERROR321");
	}
	va.setType(type);
	va.addVariable(name);		
	RESULT= va;	
:};

variableA ::=  ID:id SEMICOLON 
{: 
	String name = id.getLexema();
	VariableA va = new VariableA(name);
	RESULT=va;
:}
 | ID:id variableB:vb SEMICOLON 	
{:
 	String name = id.getLexema();
	VariableA va = new VariableA(vb.getVariables(), vb.getType());
	va.setIntermediateCode(vb.getIntermediateCode());
	va.addVariable(name);
	RESULT=va;
:}		 
 | ID:id variableC:vc SEMICOLON 
{:
 	String name = id.getLexema();
 	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	SymbolTableIF sTable = scope.getSymbolTable();
	if (sTable.containsSymbol(name))
		semanticErrorManager.semanticFatalError("Variable77 : "+name+" duplicada " + id.getLine() + id.getColumn());
	VariableA va = new VariableA(vc.getType());
	
	SymbolVariable sv = new SymbolVariable(scope, name, new TypeSimpleInteger(scope));
	sTable.addSymbol(sv);
	TemporalIF temp = vc.getTemporal();
	System.out.println(vc.getIntermediateCode ());
	cb.addQuadruples (vc.getIntermediateCode ());

	cb.addQuadruple ("MV", new Variable(sv), temp); 
	va.setIntermediateCode(cb.create());
	RESULT=va;
:}
 | ID:id variableC:vc variableB:vb SEMICOLON 
{:
 	String name = id.getLexema();
 	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	SymbolTableIF sTable = scope.getSymbolTable();
	if (sTable.containsSymbol(name))
		semanticErrorManager.semanticFatalError("Variable88 : "+name+" duplicada " + id.getLine() + id.getColumn());
		
	TypeIF type = vc.getType();
	TypeIF typeLista =vb.getType();
	VariableA va=new VariableA();

	if (typeLista==null){
		va=new VariableA(vb.getVariables(), type);
		va.setType(type);
	} else if (typeLista.equals(type)) {
		va=new VariableA(vb.getVariables(), typeLista);
	} else
		semanticErrorManager.semanticFatalError("La variable "+name+" no es del mismo tipo que las declaradas." +" Linea: " +id.getLine() +" Columna: "+ id.getColumn());
		
	SymbolVariable sv = new SymbolVariable(scope, name, new TypeSimpleInteger(scope));
	sTable.addSymbol(sv);
	TemporalIF temp = vc.getTemporal();
	cb.addQuadruples (vc.getIntermediateCode ()); 
	cb.addQuadruple ("MV", new Variable(sv), temp); 
	cb.addQuadruples (vb.getIntermediateCode ()); 

	va.setIntermediateCode(cb.create());	
		
	RESULT=va;
:};


variableB ::= COMMA ID:id variableB:vb //,x otra
{:
//iniciar valor por defecto???
	String name = id.getLexema();
		ScopeIF scope = scopeManager.getCurrentScope();
	//IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	//cb.addQuadruples (vb.getIntermediateCode ());
	//vb.setIntermediateCode(cb.create());
	vb.addVariable(name);
	RESULT=vb;			
:}
| COMMA ID:id //x
{:
	String name = id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	
	VariableB vb = new VariableB(name);
	RESULT=vb;	
:}
| COMMA ID:id variableC:vc // , x=3 // 
{:
	String name = id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	SymbolTableIF sTable = scope.getSymbolTable();
	if (sTable.containsSymbol(name))
		semanticErrorManager.semanticFatalError("Variable99 : "+name+" duplicada " + id.getLine() + id.getColumn());
	VariableB vb = new VariableB();
	SymbolVariable sv = new SymbolVariable(scope, name, new TypeSimpleInteger(scope));
	sTable.addSymbol(sv);
	TemporalIF temp = vc.getTemporal();
	cb.addQuadruples (vc.getIntermediateCode ());
	cb.addQuadruple ("MV", new Variable(sv), temp); 
	vb.setIntermediateCode(cb.create());
	RESULT=vb;	
:}
| COMMA ID:id variableC:vc variableB:vb //,x=3,otra //int x=3, contador
{:
	String name = id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	SymbolTableIF sTable = scope.getSymbolTable();
	if (sTable.containsSymbol(name))
		semanticErrorManager.semanticFatalError("Variable11 : "+name+" duplicada " + id.getLine() + id.getColumn());
	TypeIF type = vc.getType();
	
	SymbolVariable sv = new SymbolVariable(scope, name, new TypeSimpleInteger(scope));
	sTable.addSymbol(sv);
	TemporalIF temp = vc.getTemporal();
	cb.addQuadruples (vc.getIntermediateCode ());
	cb.addQuadruple ("MV", new Variable(sv), temp); 
	cb.addQuadruples (vb.getIntermediateCode ());
	vb.setIntermediateCode(cb.create());
	RESULT=vb;		
:};

variableC ::= ASSIGMENT NUM:nu //tras asignar o numero 
{:
	String name = nu.getLexema();
	Integer valor = new Integer(Integer.valueOf(name));
	ScopeIF scope = scopeManager.getCurrentScope();
	TemporalFactoryIF tf =new TemporalFactory(scope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scope);
	TemporalIF temp = tf.create(); //guardara el valor temporalmente

	cb.addQuadruple ("MV", temp, new Value(valor)); 

	TypeIF tipo = new TypeSimpleInteger(scope); //creo un tipo simpleInteger
	VariableC varC= new VariableC(nu.getLexema(), tipo); 
	varC.setTemporal(temp);
	varC.setIntermediateCode(cb.create()); 
	RESULT= varC;
:}
 | ASSIGMENT ID:id //o otra variable de un tipo conocido
{: 
	String name = id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();
	TemporalFactoryIF tf =new TemporalFactory(scope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scope);

	TemporalIF temp = tf.create(); //guardara el valor temporalmente
	SymbolIF symbol = scopeManager.searchSymbol(name); //en todo scope abierto
	
	TypeIF tipo = symbol.getType();
	if(tipo==null)
		semanticErrorManager.semanticFatalError(name+" No 888 tipo declarado" + id.getLine() + id.getColumn());
	
	Variable var = null;
	if (symbol instanceof SymbolVariable) 
		var = new Variable((SymbolVariable) symbol);
	else if (symbol instanceof SymbolParameter) 
		var = new Variable((SymbolParameter) symbol);
	
	cb.addQuadruple ("MV", temp, var); 
	VariableC varC= new VariableC(name, tipo); 
	varC.setTemporal(temp);
	varC.setIntermediateCode(cb.create()); 
	
	RESULT= varC;
:} ;

/*********************************************
//Expresion logica
*********************************************/

expLog ::= expLog:e1 operador:operacion expLog:e2 //operacion
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	//String operacion =op.getTipoOperador();
	TypeIF tipo1 = e1.getType();
	TypeIF tipo2 = e2.getType();

	TemporalFactoryIF tf =new TemporalFactory(scope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scope);
	TemporalIF temp1 = e1.getTemporal();
	TemporalIF temp2 = e2.getTemporal();
	TemporalIF temp = tf.create();
	cb.addQuadruples (e1.getIntermediateCode ()); 
	cb.addQuadruples (e2.getIntermediateCode ()); 
	
	switch (operacion) {
	    case "MINUS":  
	    	if (tipo1 instanceof TypeSimpleInteger && tipo2 instanceof TypeSimpleInteger ) {
	    		ExpLog e = new ExpLog(new TypeSimpleInteger(scope));
	    		cb.addQuadruple ("SUB", temp, temp1, temp2); 
	    		e.setTemporal (temp); 
	    		e.setIntermediateCode (cb.create()); 
	    	    RESULT = e;
	    	    break;
    	    } else
	    		semanticErrorManager.semanticFatalError("La expresion aritmetica debe ser tipo Entera : ");
	    case "OR":  
	    	if (tipo1 instanceof TypeSimpleInteger && tipo2 instanceof TypeSimpleInteger) {
	    		ExpLog e = new ExpLog(new TypeSimpleInteger(scope)); 
	    		cb.addQuadruple ("OR", temp, temp1, temp2); 
	    		e.setTemporal (temp); 
	    		e.setIntermediateCode (cb.create()); 
	    	    RESULT = e;
	    	    break;
		    	
		   	} else
	    		semanticErrorManager.semanticFatalError("La operacion OR debe comparar dos bool 888: ");	
	    case "MORE":  
	    	if (tipo1 instanceof TypeSimpleInteger && tipo2 instanceof TypeSimpleInteger ) { 

	    		ExpLog e = new ExpLog(new TypeSimpleInteger(scope));
	    		
	    		cb.addQuadruple ("GR", temp, temp1, temp2); 
	    		e.setTemporal (temp); 
	    		e.setIntermediateCode (cb.create()); 
	    	    RESULT = e;
	    	    break;
	    	}  	else
	    		semanticErrorManager.semanticFatalError("La operacion > debe ser entre dos expresiones aritmeticas");
	    case "EQUAL":  
	    	if (tipo1 instanceof TypeSimpleInteger && tipo2 instanceof TypeSimpleInteger ){
	    		ExpLog e = new ExpLog(new TypeSimpleInteger(scope)); //lo a人de como bool
	    		cb.addQuadruple ("EQ", temp, temp1, temp2); 
	    		e.setTemporal (temp); 
	    		e.setIntermediateCode (cb.create()); 
	    	    RESULT = e;
	    	    break;
	    	} else
	    		semanticErrorManager.semanticFatalError("La operacion == debe ser entre dos expresiones aritmeticas");
		default:
            semanticErrorManager.semanticFatalError("OPERADOR INVALIDO");
            break;
     }
:}
| OBRACKET expLog:el  CBRACKET  // contenida entre parentesis
{:
	RESULT= el;
:}
| ID:id //un simple id
{:
	String name = id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolIF symbol = scopeManager.searchSymbol(name);
	TypeIF tipo= symbol.getType(); 

	if (tipo==null)
		semanticErrorManager.semanticFatalError(name+" no ha sido declarado. "+" Linea: " +id.getLine() +" Columna: "+ id.getColumn());
	if (!(tipo instanceof TypeSimpleInteger))
		semanticErrorManager.semanticFatalError(name+" no es de tipo ENTERO. "+" Linea: " +id.getLine() +" Columna: "+ id.getColumn());		

	ExpLog e = new ExpLog(new TypeSimpleInteger(scope));
	
	//Si sabemos que la referencia es a una constante o variable de tipo entero, se procede
	TemporalFactory tf = new TemporalFactory(scope);
	TemporalIF temp = tf.create();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);

	if (symbol instanceof SymbolConstant){
		SymbolConstant sc = (SymbolConstant) symbol;
		cb.addQuadruple("MV", temp, new Value(sc.getValue()) ); //mueve el valor a temp
	} else if (symbol instanceof SymbolVariable) {
		SymbolVariable sv = (SymbolVariable) symbol;
		Variable var = new Variable(sv);
		
		cb.addQuadruple("MV", temp, var); //temp es la direccion de var
	} else if (symbol instanceof SymbolParameter) {
		SymbolParameter sp = (SymbolParameter) symbol;
		Variable var = new Variable(sp);
		
		cb.addQuadruple("MV", temp, var); //temp es la direccion de var
	}
	e.setTemporal(temp);
	e.setIntermediateCode(cb.create());
	RESULT = e;
:}
| NUM:n 
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	ExpLog e = new ExpLog(new TypeSimpleInteger(scope)); //lo a人de como integer
	
	int value = new Integer(Integer.valueOf(n.getLexema()));
	
	TemporalFactory tf = new TemporalFactory(scope);
	TemporalIF temp = tf.create();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruple("MV", temp, new Value(Integer.parseInt(n.getLexema()))); //mueve valor a temp
	e.setTemporal(temp);
	e.setIntermediateCode(cb.create());
	
	RESULT = e;
:}
| invFunc:inf 
{: 
	String name = inf.getName();
	ScopeIF scope = scopeManager.getCurrentScope();
	
	SymbolIF symbol=scopeManager.searchSymbol(name);
	TypeIF tipo =symbol.getType();
	
	if (tipo==null)
		semanticErrorManager.semanticFatalError(name+" no ha sido declarado. ");
	if (tipo instanceof TypeSimpleVoid)
		semanticErrorManager.semanticFatalError(name+" es un procedimiento sin retorno. No puede asignarse.");
	if (!(tipo instanceof TypeSimpleInteger))
		semanticErrorManager.semanticFatalError("La funcion "+name+" invocada no devuelve un tipo entero.");
	if (!(symbol instanceof SymbolFunction || symbol instanceof SymbolProcedure))
		 semanticErrorManager.semanticFatalError("ERROR FATAL DE FUNCION");

	SymbolProcedure sym = (SymbolProcedure) symbol;
	if (inf.getNumberOfParameters() != sym.getNumberOfParameters()) 
		semanticErrorManager.semanticFatalError("Numero de Parametros no coincide!!!");
	
	ExpLog elog=new ExpLog(new TypeSimpleInteger(scope), true); //identifica esta expLog como llamada
	elog.setIntermediateCode(inf.getIntermediateCode()); //coge el codigo intermedio, se gestiona en invFunc
	RESULT = elog;

:}
| expAcceso:ea
{: //WIP meter codigo intermedio de acceso, ejemplo buscar la variable y moverla
	ScopeIF scope = scopeManager.getCurrentScope();
	ExpLog e = new ExpLog(new TypeSimpleInteger(scope));
	TemporalFactory tf = new TemporalFactory(scope);
	TemporalIF temp = tf.create();
	Variable var = new Variable(ea.getVariable());
	var.setOffset(ea.getOffset());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruple("MV", temp, var); //mueve variable acceso a temp
	e.setTemporal(temp);
	e.setIntermediateCode(cb.create());
	
	RESULT = e;
:};
	
/*********************************************
//operador
*********************************************/		
operador::= 
MINUS {:RESULT=new String("MINUS");:}
| OR {:RESULT=new String("OR");:}
| MORE {:RESULT=new String("MORE");:}
| EQUAL {:RESULT=new String("EQUAL");:};

/*********************************************
//Expresion acceso
*********************************************/		

expAcceso ::= ID:id1 POINT ID:id2 //cuadrado.x 
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	String nombre1 = id1.getLexema(); //tipo
	String nombre2 = id2.getLexema(); //acceso

	SymbolIF symbol1=scopeManager.searchSymbol(nombre1); 	//comprueba si el primer simbolo es Tipo record y esta en un ambito alcanzable
	if (symbol1==null) 
		semanticErrorManager.semanticFatalError("No es una variable valida para esa expresion de acceso." + id1.getLine() + id1.getColumn());
	
	TypeIF tipo1 = symbol1.getType(); //si tengo simbolo, compruebo el tipo
	if (!(tipo1 instanceof TypeRecord)) 
		semanticErrorManager.semanticFatalError(nombre1 + "no es del tipo registro" + id1.getLine() + id1.getColumn());
	TypeRecord tipo1r = (TypeRecord) tipo1;

	ScopeIF scope1=null;	
	//WIP quizas solo en los scope abiertos.....
	for (ScopeIF s : scopeManager.getAllScopes()) // busqueda en todos los scopes para encontrar la declaracion del tipo
		if(s.getName().equals(tipo1.getName()))
			scope1 =s;
	if(scope1.equals(null))
		semanticErrorManager.semanticFatalError(nombre1+" no es un tipo declaradoZZZ " + id1.getLine() + id1.getColumn());	
	//WIP quizas solo en los scope abiertos.....
		
	SymbolTableIF sTable1 = scope1.getSymbolTable(); //recojo tabla de simbolos del campo1	
	if(!sTable1.containsSymbol(nombre2)) 	//si la tabla no tiene el segundo simbolo y este no es de tipo int, salir
		semanticErrorManager.semanticFatalError("No es del tipo o no se encuentra888 " + id1.getLine() + id1.getColumn());	
	if (!(sTable1.getSymbol(nombre2).getType() instanceof TypeSimpleInteger)) 
		 semanticErrorManager.semanticFatalError(nombre1+" no es del tipo registro." + id1.getLine() + id1.getColumn());

	SymbolIF symbol= sTable1.getSymbol(nombre2); //cojo el segundo simbolo
	if (!(symbol instanceof SymbolVariable)) 
		semanticErrorManager.semanticFatalError(nombre2+" no es una variable valida dentro del struct." + id1.getLine() + id1.getColumn());
	
	SymbolVariable sv = (SymbolVariable) symbol; //cast a SymbolVariable para poder operar
	int offset = tipo1r.getOffset(nombre2); //se recoje del primer campo
	SymbolVariable sG = (SymbolVariable) symbol1;

	ExpAcceso ea = new ExpAcceso(nombre1, nombre2, new TypeSimpleInteger(scope), sG, offset);
	RESULT=ea;
		
:} | ID:id1 POINT ID:id2 POINT ID:id3 {:

	String nombre1 = new String (id1.getLexema()); //tipo
	String nombre2 = new String (id2.getLexema()); //acceso
	String nombre3 = new String (id3.getLexema()); //acceso
	
	ScopeIF scope = scopeManager.getCurrentScope();
	
	SymbolIF symbol1=scopeManager.searchSymbol(nombre1); 	//comprueba si el primer simbolo es Tipo record y esta en un ambito alcanzable
	if (symbol1==null) 
		semanticErrorManager.semanticFatalError("No es una variable valida para esa expresion de acceso." + id1.getLine() + id1.getColumn());
	
	TypeIF tipo1 =symbol1.getType(); //comprueb el tipo
	if (!(tipo1 instanceof TypeRecord)) //&& tipo2 instanceof TypeRecord)) 
		semanticErrorManager.semanticFatalError(nombre1 + " no es del tipo registro" + id1.getLine() + id1.getColumn());
	
	TypeRecord tipo1r = (TypeRecord) tipo1;
	
	//WIP solo tablas de tipos abiertas???
	ScopeIF scope1=null;
	for (ScopeIF s : scopeManager.getAllScopes())  // busqueda en todos los scopes para encontrar la declaracion del tipo
		if(s.getName().equals(tipo1.getName()))
			scope1 =s;
	if(scope1.equals(null))
		semanticErrorManager.semanticFatalError(nombre1+" no es un tipo declaradoZZZ " + id1.getLine() + id1.getColumn());
	//WIP solo tablas de tipos abiertas???

	SymbolTableIF sTable1 = scope1.getSymbolTable(); //recojo su tabla de simbolos				
	if(!sTable1.containsSymbol(nombre2)) 	//si la tabla no tiene el segundo simbolo y este no es de tipo record, salir
		semanticErrorManager.semanticFatalError("No es del tipo o no se encuentra9997 " + id1.getLine() + id1.getColumn());	
	if (!(sTable1.getSymbol(nombre2).getType() instanceof TypeRecord)) 
		 semanticErrorManager.semanticFatalError(nombre2+" no es del tipo registro." + id1.getLine() + id1.getColumn());

	// Hasta que se comprueba que el nombre 2 es de tipo struct y pertenece a nombre1
	//Ahora ver si nombre 3 esta en el ambito de nombre 2 y es int
	//WIP solo tablas de tipos abiertas???
	ScopeIF scope2=null;		
	for (ScopeIF s : scopeManager.getAllScopes()) { // busqueda en todos los scopes para encontrar la declaracion del tipo
		if(s.getName().equals(sTable1.getSymbol(nombre2).getType().getName()))
			scope2 =s;
	}
	if(scope2.equals(null))
		semanticErrorManager.semanticFatalError(nombre2+" no es un tipo declaradoZZZ " + id1.getLine() + id1.getColumn());
	//WIP solo tablas de tipos abiertas???

	SymbolTableIF sTable2 = scope2.getSymbolTable(); //recojo su tabla de simbolos	
	if(!sTable2.containsSymbol(nombre3)) 	//si la tabla no tiene el tercer simbolo y este no es de tipo int, salir
		semanticErrorManager.semanticFatalError("No es del tipo o no se encuentra9998 " + id1.getLine() + id1.getColumn());	
	if (!(sTable2.getSymbol(nombre3).getType() instanceof TypeSimpleInteger)) 
		semanticErrorManager.semanticFatalError(nombre3+" no es del tipo registro." + id1.getLine() + id1.getColumn());

	SymbolIF symbol2= sTable1.getSymbol(nombre2); //coge el segundo
	SymbolIF symbol3= sTable2.getSymbol(nombre3); //coge el tercero

	TypeIF tipo2 =symbol2.getType(); //comprueb el tipo
	if (!(tipo2 instanceof TypeRecord)) //&& tipo2 instanceof TypeRecord)) 
		semanticErrorManager.semanticFatalError(nombre2 + " no es del tipo registro" + id1.getLine() + id1.getColumn());
	TypeRecord tipo2r = (TypeRecord) tipo2;

	if (!(symbol3 instanceof SymbolVariable)) 
		semanticErrorManager.semanticFatalError(nombre3+" no es una variable." + id1.getLine() + id1.getColumn());
	SymbolVariable sv2 = (SymbolVariable) symbol2;
	SymbolVariable sv3 = (SymbolVariable) symbol3;
	
	int offset2 = tipo1r.getOffset(nombre2); //se recoge el offset del segundo campo
	int offset3 = tipo2r.getOffset(nombre3); //se recoge el offset del tercer campo

	//Variable var = new Variable(sv3);
	SymbolVariable sG = (SymbolVariable) symbol1; //variable de primer tipo para pasar junto a el offset
	//sG.setOffset(offset2+offset3);
	ExpAcceso ea= new ExpAcceso(nombre1, nombre2, nombre3, new TypeSimpleInteger(scope), sG, (offset2+offset3));	
	RESULT=ea;
:} ;

/*****************************
//Expresion asignacion
*****************************/
expAsig ::= ID:id ASSIGMENT expLog:el
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();
	//SymbolTableIF sTable = scope.getSymbolTable();

	SymbolIF symbol= scopeManager.searchSymbol(name);
	/*
	System.out.println("el simbolo ES: "+symbol);
	
	List<ScopeIF> scopes = scopeManager.getAllScopes(); 
		for (ScopeIF s: scopes)  //inserta los textos como espacio dentro de variables globales 
			for (SymbolIF symbo: s.getSymbolTable ().getSymbols())
				System.out.println("scope: " +s+" simbolo :" +symbo); 
	*/
	if (!(symbol instanceof SymbolVariable || symbol instanceof SymbolParameter))
		semanticErrorManager.semanticFatalError(name+" no es un nombre de variable o parametro previamente declarado o dentro de alcance."+" Linea: "+id.getLine()+" Columna: "+id.getColumn());
	TypeIF tipo=symbol.getType();
	
	if (tipo==null)
		semanticErrorManager.semanticFatalError("Variable: "+name+" no ha sido declarado o fuera de alcance."+" Linea: "+id.getLine()+" Columna: "+id.getColumn());
	if (!(el.getType().getName().equals(tipo.getName()) )) 
		semanticErrorManager.semanticFatalError("No coinciden los tipos en la asignaci蚤."+" Linea: "+id.getLine());
	
	Expresion ea=new Expresion(tipo); 
	
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	TemporalIF elTemp = el.getTemporal();
	cb.addQuadruples(el.getIntermediateCode());
	
	Variable var = null;
	if (symbol instanceof SymbolVariable) 
		var = new Variable((SymbolVariable) symbol);
	else if (symbol instanceof SymbolParameter) 
		var = new Variable((SymbolParameter) symbol);
	else
		semanticErrorManager.semanticFatalError("ERROR GRAVE."+" Linea: "+id.getLine());
	//algo mas complejo????
	
	if(el.isCall()){
		
		cb.addQuadruple("ASIG", var);
		System.out.println("USO ASIG");
		System.out.println(""+var.getName());
		System.out.println(""+var.getScope());
		System.out.println(""+var.getScope().getLevel());
		System.out.println("*************************");
		//cb.addQuadruple("MV", var, elTemp);
		
		}
	else
		cb.addQuadruple("MV", var, elTemp); //de temp de exp logica a la direccion de la variable
		
	ea.setIntermediateCode(cb.create());
	
	//WIP y si fuese una invocacion??
	
	RESULT=ea;	
			
:}
| 
expAcceso:ea ASSIGMENT:a expLog:el 
{:
	String name = ea.getName(); //recoge el nombre de la var exp acceso, lo necesito para el desplazamiento relativo
	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	if (!(ea.getType().getName().equals(el.getType().getName()) ) )
		semanticErrorManager.semanticFatalError("No coinciden los tipos en la asignaci蚤."+" Linea: "+a.getLine());
		
	SymbolIF symbol= scopeManager.searchSymbol(name);
	if (!(symbol instanceof SymbolVariable || symbol instanceof SymbolParameter))
		semanticErrorManager.semanticFatalError(name+" no es un nombre de variable o parametro previamente declarado o dentro de alcance."+" Linea: "+a.getLine()+" Columna: "+a.getColumn());

	Expresion exp = new Expresion(el.getType());

	TemporalIF elTemp = el.getTemporal(); //el temporal de la expresionLogica
	int offset = ea.getOffset(); //cojo el desplazamiento
	cb.addQuadruples(el.getIntermediateCode());
	Variable var = null;
		
	if (symbol instanceof SymbolVariable) {
		SymbolVariable sv = (SymbolVariable) symbol;
		var = new Variable(sv);
	} else if (symbol instanceof SymbolParameter) {
		SymbolParameter sp = (SymbolParameter) symbol;
		var = new Variable(sp);
	}	
	var.setOffset(offset);
	
	if(el.isCall()) {
		cb.addQuadruple("ASIG", var);
		System.out.println("USO ASIG en Scope");
		}
	else
		cb.addQuadruple("MV", var, elTemp); //de temp de exp logica a la direccion de la variable
	
	//cb.addQuadruple("MV", var, elTemp);	//mover el temp de explog a la direccion de la var de acceso mas desplazamiento
	exp.setIntermediateCode(cb.create());	
	RESULT = exp;
:};
			
/**************************************************
//expresion
***************************************************/
expresion ::= expLog:el 
{:
	Expresion e= new Expresion (el.getType());

	e.setIntermediateCode(el.getIntermediateCode());
	TemporalIF temp = el.getTemporal();
	e.setTemporal(temp);
	RESULT =e;
:}
 | expAsig:ea 
{: 
	Expresion e=new Expresion (ea.getType());

	e.setIntermediateCode(ea.getIntermediateCode());
	TemporalIF temp = ea.getTemporal();
	e.setTemporal(temp);

 	RESULT= e;  
 :};
	
/**************************************************
//Invocar funci칩n. VERSION ANTIGUA QUE NO FUNCIONA
***************************************************/
/***************************************************
invFunc ::= ID:id OBRACKET invFuncA:inv ;
invFuncA ::= CBRACKET 
| expresion:e CBRACKET {::}
| expresion:e COMMA invFuncA:inv {::};	
****************************************************/

/**************************************************
//Invocar funcion. 
***************************************************/
// al invocar, todos los parametros deben de ser tipo INT
// el enunciado dice que por valor no pueden pasarse ni matrices ni registros
// solo pueden pasarse invocaciones, ref a variables, numeros, int dentro de un registro
// solo importa el numero, el orden al ser todo ints depende del usuario

invFunc ::= ID:id OBRACKET invFuncA:inv CBRACKET //ej. decrementar ( invFunA )
{:
	String name = id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();
	
	if (!(scope.getName().equals(name))) //si no es recursiva, comprueba si esta declarada previamente
		if (!(scopeManager.containsSymbol(name)))
			semanticErrorManager.semanticFatalError("No se puede invocar: "+name+" no ha sido declarado."+" Linea: "+id.getLine()+" Columna: "+id.getColumn());
	SymbolIF symbol = scopeManager.searchSymbol(name);
	
	if (!(symbol instanceof SymbolProcedure || symbol instanceof SymbolProcedure)) 
		semanticErrorManager.semanticFatalError(name+" no es una metodo valido."+" Linea: "+id.getLine()+" Columna: "+id.getColumn());

	TypeIF tipo = symbol.getType();
	
	if (tipo==null) 
		semanticErrorManager.semanticFatalError("Procedimiento: "+name+" no ha sido declarado."+" Linea: "+id.getLine()+" Columna: "+id.getColumn());
	
	InvFunc invf = new InvFunc(name, tipo, inv.getNumberOfParameters());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);

	//codigo por parametro
	for (Expresion parametro: inv.getParameters()) {
		cb.addQuadruples(parametro.getIntermediateCode()); //a人de el codigo de cada parametro (si existe)
		cb.addQuadruple("PARAM", parametro.getTemporal()); //genera CI
	} 
	
	ScopeIF scopeX = null;
	List<ScopeIF> scopes = scopeManager.getAllScopes(); //recoge el scope con ese nombre
	for (ScopeIF s : scopes)
		if (s.getName().equals(name))
			scopeX=s;
	Variable fun = new Variable(name, scopeX); //CAMBIO
	cb.addQuadruple("CALL", fun, inv.getNumberOfParameters());
	invf.setIntermediateCode(cb.create());
	
	RESULT=invf;
:}
| ID:id OBRACKET CBRACKET //sin parametros, si parentesis
{:
	String name = id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();
	
	if (!(scope.getName().equals(name))) //si no es recursiva, comprueba si esta declarada previamente
		if (!(scopeManager.containsSymbol(name)))
			semanticErrorManager.semanticFatalError("No se puede invocar: "+name+" no ha sido declarado."+" Linea: "+id.getLine()+" Columna: "+id.getColumn());
	SymbolIF symbol = scopeManager.searchSymbol(name);
	TypeIF tipo = symbol.getType();
	
	if (tipo==null)
		semanticErrorManager.semanticFatalError("Procedimiento: "+name+" no ha sido declarado."+" Linea: "+id.getLine()+" Columna: "+id.getColumn());
	//if (!(tipo instanceof TypeSimpleInteger))
		//semanticErrorManager.semanticFatalError("La funcion "+name+" invocada no devuelve un tipo entero."+" Linea: "+id.getLine()+" Columna: "+id.getColumn());

	if (!(symbol instanceof SymbolFunction || symbol instanceof SymbolProcedure)) 
		semanticErrorManager.semanticFatalError(""+name+" no es un procediemiento o una funcion."+" Linea: "+id.getLine()+" Columna: "+id.getColumn());
	InvFunc invf = new InvFunc(name, tipo, 0);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);

	ScopeIF scopeX = null;
	List<ScopeIF> scopes = scopeManager.getAllScopes(); //recoge el scope con ese nombre
	for (ScopeIF s : scopes)
		if (s.getName().equals(name))
			scopeX=s;
	Variable fun = new Variable(name, scopeX); //cambio antes era scope
	cb.addQuadruple("CALL", fun, 0);
	invf.setIntermediateCode(cb.create());
	RESULT=invf;
:};

// parametros funcion
invFuncA ::= expresion:e
{:
	if (!(e.getType() instanceof TypeSimpleInteger))
		semanticErrorManager.semanticFatalError("Parametros no son del tipo correcto");
	
	InvFuncA inva= new InvFuncA(e);
	
	RESULT=inva;
:}  
| invFuncA:inv COMMA expresion:e
{:
	if (!(e.getType() instanceof TypeSimpleInteger))
		semanticErrorManager.semanticFatalError("Parametros no son del tipo correcto");
	
	inv.add(e);
	RESULT=inv;
	
:};
            
/***********************            
//Sentencia for
***********************/

//WIP sacar las cosas del for de la clases sentForA y craer codigo intermedio
sentFor ::=  sentForA:sfa SEMICOLON //para el infinito 
{:
	NonTerminalGeneric senfor = new NonTerminalGeneric();
	senfor.setIntermediateCode(sfa.getIntermediateCode());
	scopeManager.closeScope();
	RESULT= senfor;
:}
| sentForA:sfa sentencia:sen //for y bloque debo crear un ambito??
{:
	NonTerminalGeneric senfor = new NonTerminalGeneric();
	ScopeIF scope = scopeManager.getCurrentScope();
	LabelFactoryIF lf = new LabelFactory (); 
	LabelIF lab1 = lf.create (); 
	LabelIF lab2 = lf.create (); 
	Variable var=new Variable (sfa.getVariable());
	var.setOffset(sfa.getOffset());
	ExpLog from=sfa.getFrom();
	Expresion to=sfa.getTo();
	Expresion inc=sfa.getInc();
	TemporalIF eTemp = from.getTemporal (); //sacar el temporal de la expresion asignada
	TemporalIF toTemp = to.getTemporal (); //sacar el temporal de la expresion asignada
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	//codigo de la asignacion. OK
	cb.addQuadruples(from.getIntermediateCode()); 
	cb.addQuadruple("MV", var, eTemp); //mover temporal de la drecha asignacion a la variable para almacenar su valor inicial
	cb.addQuadruple("INL", lab1); // empieza el bucle
	cb.addQuadruples(to.getIntermediateCode()); //compruebo el codigo de hasta
	cb.addQuadruple("BRT", toTemp, lab2);//si condicion dos es cierto salto a lab 2 y salgo !!!!!!!!!!!!!!!!!!!!
	cb.addQuadruples(sen.getIntermediateCode()); //si es cierto, a人do la sentencia a todo el codigo
	cb.addQuadruples(inc.getIntermediateCode()); //aplico el incremento
	cb.addQuadruple("BRF", toTemp,  lab1); //comprubo condicion, si es falsa vuevo a comenzar el bucle !, si es verdadera sigo
	cb.addQuadruple("INL", lab2); //salida del bucle
	
	senfor.setIntermediateCode(cb.create());
	
	scopeManager.closeScope();
	RESULT= senfor;
:};
			 
sentForA ::= FOR OBRACKET ID:id ASSIGMENT expLog:elog SEMICOLON expresion:e1 SEMICOLON expresion:e2 CBRACKET //declaracion con un id
// for (tipo=tipo2;tipo3;tipo4) OK
{:
	scopeManager.openScope();
	ScopeIF scope = scopeManager.getCurrentScope();
	String name= id.getLexema();
	SymbolIF symbol = scopeManager.searchSymbol(name);
	//WIP comprobar si es variable
	TypeIF tipo1= symbol.getType(); // buscarTipoVariable(level, name);

	if (tipo1==null)
		semanticErrorManager.semanticFatalError("La variable "+name+" no ha sido declarado en ningun ambito previo."+" Linea: "+id.getLine()+" Columna: "+id.getColumn());
	TypeIF tipo2= elog.getType(); TypeIF tipo3= e1.getType(); TypeIF tipo4= e2.getType();
	
	if (!(tipo1 instanceof TypeSimpleInteger && tipo2 instanceof TypeSimpleInteger &&
	    tipo3 instanceof TypeSimpleInteger && tipo4 instanceof TypeSimpleInteger)) 		//Todos los tipos son validos
		semanticErrorManager.semanticFatalError("Las declaraciones de la sentencia for no son del tipo adecuado."+" Linea: "+id.getLine()+" Columna: "+id.getColumn());
	
	//TemporalIF eTemp = elog.getTemporal (); //sacar el temporal de la expresion asignada
	//WIP meter tambien parametros
	SymbolVariable var = (SymbolVariable)symbol;
	SentForA senfor = new SentForA(var, elog, e1, e2);	
	RESULT =senfor ;
:}
|FOR:id OBRACKET expAcceso:eac ASSIGMENT expLog:elog SEMICOLON expresion:e1 SEMICOLON expresion:e2 CBRACKET //declaracion con un acceo
//WIP
{:
	scopeManager.openScope();
	ScopeIF scope = scopeManager.getCurrentScope();
	TypeIF tipo1 = eac.getType() ;	TypeIF tipo2= elog.getType();
	TypeIF tipo3= e1.getType();	TypeIF tipo4= e2.getType();
	
	if (!(tipo1 instanceof TypeSimpleInteger && tipo2 instanceof TypeSimpleInteger &&
	    tipo3 instanceof TypeSimpleInteger && tipo4 instanceof TypeSimpleInteger)) //Todos los tipos son validos
		semanticErrorManager.semanticFatalError("Las declaraciones de la sentencia for no son del tipo adecuado."+" Linea: "+id.getLine()+" Columna: "+id.getColumn());
//WIP meter tambien parametros
	SymbolVariable var= eac.getVariable(); //debe ser mejorado
	
	SentForA senfor = new SentForA(var, elog, e1, e2, eac.getOffset());	
	
	RESULT =senfor ;
:};			 			 

/************************************
//Sentencia printi
************************************/
sentEntrada ::= PRINTI OBRACKET ID:id CBRACKET SEMICOLON 
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	String name = id.getLexema();
	System.out.println("ALERTA!!!!!!!!!!!");
	if(!scopeManager.containsSymbol(name))
		semanticErrorManager.semanticFatalError("Variable : "+name+" no ha sido declarada." +" Linea: " +id.getLine() +" Columna: "+ id.getColumn());

	Sentencia sen= new Sentencia();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scope);
	SymbolIF symbol = scopeManager.searchSymbol(name);

	if(symbol instanceof SymbolVariable) {
		cb.addQuadruple("PRINT", new Variable((SymbolVariable) symbol)); //sentencia de print
	} else if (symbol instanceof SymbolParameter) {
		cb.addQuadruple("PRINT", new Variable((SymbolParameter) symbol)); //sentencia de print
	} else {
		semanticErrorManager.semanticFatalError(""+name+" no hace referencia a una variable o un parametro." +" Linea: " +id.getLine() +" Columna: "+ id.getColumn());
	}
	sen.setIntermediateCode(cb.create());
	RESULT= new Sentencia();
:}
| PRINTI OBRACKET expresion:e CBRACKET SEMICOLON //
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	Sentencia sen= new Sentencia();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scope);
	TemporalIF eTemp = e.getTemporal(); //buscar el temp de expresion
	cb.addQuadruples(e.getIntermediateCode()); //buscar el codigo intermedio

	cb.addQuadruple("PRINT", eTemp);
	sen.setIntermediateCode(cb.create());
	RESULT= sen;
:}
| PRINTI OBRACKET CBRACKET SEMICOLON
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	Sentencia sen= new Sentencia();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scope);
	cb.addQuadruple("PRINT");
	sen.setIntermediateCode(cb.create());
	RESULT= sen;
:}; 

/************************************
//Sentencia printc
************************************/
//Solo deberia funcionar con cadenas tipo "hola mundo"
sentSalida ::= PRINTC OBRACKET TCHAIN:tch CBRACKET SEMICOLON
{: 
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF sTable = scope.getSymbolTable();
	Sentencia sen= new Sentencia();
	String name="str_"+tch.getLine()+"_"+ tch.getColumn(); //genera un nombre unico para la variable string
	
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scope);
	
	//WIP craer un Symbol constant funcionaria mejor????
	SymbolConstantString scs = new SymbolConstantString(scope, name, new TypeString(scope), tch.getLexema());
	//SymbolVariable sv = new SymbolVariable(scope, name, new TypeString(scope, tch.getLexema()));
	sTable.addSymbol(name, scs);	
	//Variable var= new Variable(scs);
	Value val = new Value(name);
	cb.addQuadruple("PRINT", val);
	sen.setIntermediateCode(cb.create());
	RESULT= sen;
:};


/************************************
//Sentencia if
************************************/

/************************************************************
Sentencia eliminada por recomendacion del ED en el foro 4/4/17
 sent_if ::= IF:id OBRACKET expresion:e CBRACKET SEMICOLON 
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	TypeIF type = e.getType();

	//if(!(type instanceof TypeSimpleInteger && (e.isBool() )))
	if(!(type instanceof TypeSimpleInteger))
		semanticErrorManager.semanticFatalError("Condicion de sentencia if no es una expresion logica"+" Linea: " +id.getLine() +" Columna: "+ id.getColumn());

	Sent_if sif=new Sent_if(e);
	sif.setIntermediateCode(e.getIntermediateCode());	
	RESULT= sif;
:}
|
****************************************************/

sent_if ::=IF:id OBRACKET expresion:e CBRACKET sentencia:sThen
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	LabelFactoryIF lf = new LabelFactory ();
		
	TypeIF type = e.getType();
	
	//if(!(type instanceof TypeSimpleInteger && ( e.isBool() )))
	if(!(type instanceof TypeSimpleInteger))
		semanticErrorManager.semanticFatalError("Condicion de sentencia if no es una expresion logica"+" Linea: " +id.getLine() +" Columna: "+ id.getColumn());
	
	Sent_if sif=new Sent_if(e, sThen);
 
	LabelIF lab1 = lf.create (); 
	TemporalIF eTemp = e.getTemporal(); 
	
	cb.addQuadruples(e.getIntermediateCode()); // a人de codigo expresion
	cb.addQuadruple("BRF", eTemp, lab1); //si no expresion salto a lab1 //comparar con 0
	cb.addQuadruples(sThen.getIntermediateCode()); //si expresion coger codigo intermedio
	cb.addQuadruple("INL", lab1); //lab1
	
	sif.setIntermediateCode(cb.create());
	RESULT= sif;
:}
|IF:id OBRACKET expresion:e CBRACKET sentencia:sThen ELSE sentencia:sElse
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	TypeIF type = e.getType();
	
	//if(!(type instanceof TypeSimpleInteger && (e.isBool() )))
	if(!(type instanceof TypeSimpleInteger ))
		semanticErrorManager.semanticFatalError("Condicion de sentencia if no es una expresion logica"+" Linea: " +id.getLine() +" Columna: "+ id.getColumn());
	
	Sent_if sif=new Sent_if(e, sThen, sElse);
	//sif.setIntermediateCode(e.getIntermediateCode());
	
	LabelFactoryIF lf = new LabelFactory(); 
	LabelIF labT = lf.create(); 
	LabelIF labF = lf.create(); 
	TemporalIF eTemp = e.getTemporal(); //el temporal de la expresion
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	
	cb.addQuadruples(e.getIntermediateCode()); // coger la expresion
	cb.addQuadruple("BRF", eTemp, labF); //si no expresion salto a lab1 y coger else
	cb.addQuadruples(sThen.getIntermediateCode()); //si expresion coger sentencias then
	cb.addQuadruple("BRT",eTemp, labT); //salto a l2 si cierto
	cb.addQuadruple("INL", labF); //crea label F
	cb.addQuadruples(sElse.getIntermediateCode());// codigo del else
	cb.addQuadruple("INL", labT);// label T
	
	sif.setIntermediateCode(cb.create());
	RESULT= sif;
	
:};		
	 
/************************************
//Sentencias
************************************/

sentencia ::= bloqueSent:bs
{:
	Sentencia sen=new Sentencia();
	sen.setIntermediateCode(bs.getIntermediateCode());
	RESULT=sen;
:}
 | sentFor:sf
{:
	Sentencia sen=new Sentencia();
	sen.setIntermediateCode(sf.getIntermediateCode());
	RESULT=sen;
:}
 | sent_if:si 
{:
	Sentencia sen=new Sentencia();
	sen.setIntermediateCode(si.getIntermediateCode());
	RESULT=sen;
:}
| sentEntrada:s 
{:
	Sentencia sen=new Sentencia();
	sen.setIntermediateCode(s.getIntermediateCode());
	RESULT=sen;
:}
| sentSalida:s 	
{:
	Sentencia sen=new Sentencia();
	sen.setIntermediateCode(s.getIntermediateCode());
	RESULT=sen;
:}		 
| expAsig:ea SEMICOLON 	
{:
	Sentencia sen=new Sentencia(ea.getType());
	sen.setIntermediateCode(ea.getIntermediateCode());
	RESULT=sen;
:}		 	
| invFunc:inv SEMICOLON 	
{:
	Sentencia sen=new Sentencia();
	sen.setIntermediateCode(inv.getIntermediateCode());
	RESULT=sen;
:}			 		 
| RETURN SEMICOLON //return;
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	
	cb.addQuadruple("RET");
	Sentencia sen =new Sentencia(true, new TypeSimpleVoid(scope));
	sen.setIntermediateCode(cb.create());
	RESULT=sen;
:}
| RETURN:id expresion:e SEMICOLON //return 15;
{:
	if (!(e.getType() instanceof TypeSimpleInteger))
		semanticErrorManager.semanticFatalError("Return no es del tipo ENTERO"+" Linea: " +id.getLine() +" Columna: "+ id.getColumn());
	
	ScopeIF scope = scopeManager.getCurrentScope();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruples(e.getIntermediateCode());
	TemporalIF temp = e.getTemporal();

	cb.addQuadruple("RET", temp, new Value(scope.getLevel())); //WIP
	
	Sentencia sen = new Sentencia(true, new TypeSimpleInteger(scope));
	sen.setTemporal(temp);
	sen.setIntermediateCode(cb.create());
	RESULT=sen;
:};
		
/***********************************
***BLOQUE SENTENCIAS
***********************************/
			   
bloqueSent ::= OBRACE:pos  
{:
	System.out.println("en que posicion esta el bloque: " +pos.getLine()+" "+pos.getColumn()+"\n");
	ScopeIF scope = scopeManager.openScope();
:}
	tiposLocales:ti variablesLocales:var sentLocales:sen  CBRACE
{: //WIP opcional quizas cambiar orden
 	
 	ScopeIF scope = scopeManager.getCurrentScope();
 	
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	Variable fun = new Variable("bloque", scope);
	NonTerminalGeneric bs = new NonTerminalGeneric();
	cb.addQuadruple("B_START", fun);
	cb.addQuadruples(var.getIntermediateCode());
	cb.addQuadruples(sen.getIntermediateCode());
	
	cb.addQuadruple("B_END", fun);
	bs.setIntermediateCode(cb.create());
	scopeManager.closeScope();
	RESULT = bs;
 :}  	 ;

tiposLocales ::= tipo:t tiposLocales:tl
{:
	tl.add(t);
	RESULT=tl;
:} | {: RESULT=new ArrayList<Tipo>(); 
:};

variablesLocales ::= variablesLocales:vl variable:var 
{:
 	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruples(vl.getIntermediateCode());
	cb.addQuadruples(var.getIntermediateCode());
	System.out.println("En var bloque");
	System.out.println(var.getIntermediateCode());
	vl.setIntermediateCode(cb.create());
	RESULT=vl;
:} | {: 
	 NonTerminalGeneric vl= new NonTerminalGeneric(); 
	 RESULT=vl;
:};
					
sentLocales ::= sentencia:sen sentLocales:sl	
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruples(sen.getIntermediateCode());
	cb.addQuadruples(sl.getIntermediateCode());
	sl.setIntermediateCode(cb.create());
	RESULT=sl;
:} | {: 
	NonTerminalGeneric sl= new NonTerminalGeneric();
	RESULT=sl; 
:};
		    	 

/************************************
//Declaracion funciones
************************************/

funcion ::= VOID ID:id // procedimiento
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF sTable = scope.getSymbolTable();

		
	if(sTable.containsSymbol(name)) 
		semanticErrorManager.semanticFatalError("La funcion "+name+" ya esta declarado en este ambito. "+" Linea: " +id.getLine() +" Columna: "+ id.getColumn());
		sTable.addSymbol(name, new SymbolProcedure(scope, name, new TypeSimpleVoid(scope)));
	ScopeIF scopeX = scopeManager.openScope(name);
:}  OBRACKET funcionS:fs {:

	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope(); 
	SymbolTableIF sTable = scope.getSymbolTable();
	
	if (!(fs.getReturnType() instanceof TypeSimpleVoid)) //comprobar return type
		semanticErrorManager.semanticFatalError("El tipo de la sentencia de retorno no coincide con el tipo de la funcion "+name+" Linea: " +id.getLine() +" Columna: "+ id.getColumn());

	//sTable.addSymbol(name, new SymbolProcedure(scope, name, new TypeSimpleVoid(scope), fs.getParameterNumber()));
	//SymbolIF symbolP = sTable.getSymbol(name);//recupero el simbolo procedimiento
	SymbolProcedure symbolP = (SymbolProcedure) sTable.getSymbol(name);
	symbolP.setNumberOfParameters(fs.getParameterNumber());
	Funcion fun= new Funcion(name, new TypeSimpleVoid(scope), fs.getParameters());

	LabelIF label = new LabelFactory().create(name);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruple("INL", label); 
	cb.addQuadruples(fs.getIntermediateCode());
	if (!(fs.hasReturn()))	
		cb.addQuadruple("RET"); 
	fun.setIntermediateCode(cb.create());
		
	RESULT=fun;
:}
| INT ID:id  
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF sTable = scope.getSymbolTable();

	if(sTable.containsSymbol(name)) 
		semanticErrorManager.semanticFatalError("La funcion "+name+" ya esta declarado en este ambito. "+" Linea: " +id.getLine() +" Columna: "+ id.getColumn());
	sTable.addSymbol(name, new SymbolProcedure(scope, name, new TypeSimpleInteger(scope)));
	ScopeIF scopeX = scopeManager.openScope(name);
	
:} OBRACKET funcionS:fs {:

	ScopeIF scope = scopeManager.getCurrentScope();
	String name=id.getLexema();

	SymbolTableIF sTable = scope.getSymbolTable();
			
	if (!(fs.getReturnType() instanceof TypeSimpleInteger)) //comprobar return type
		semanticErrorManager.semanticFatalError("El tipo de la sentencia de retorno no coincide con el tipo de la funcion "+name+" Linea: " +id.getLine() +" Columna: "+ id.getColumn());

	//sTable.addSymbol(name, new SymbolProcedure(scope, name, new TypeSimpleInteger(scope), fs.getParameterNumber()));
	SymbolProcedure symbolP = (SymbolProcedure) sTable.getSymbol(name);
	symbolP.setNumberOfParameters(fs.getParameterNumber());
	Funcion fun= new Funcion(name, new TypeSimpleInteger(scope), fs.getParameters());
	LabelIF label = new LabelFactory().create(name);
		
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruple("INL",label); // uno por funcion, para test
	cb.addQuadruples(fs.getIntermediateCode());
	fun.setIntermediateCode(cb.create());
	
	RESULT=fun;

:};


funcionS ::=  funcionE:fe CBRACKET OBRACE funcionA:fa CBRACE // parametros){sentencias}
{:

	ScopeIF scope = scopeManager.getCurrentScope();			
	SymbolTableIF sTable = scope.getSymbolTable();
	
	//gestion offsets de los parametros
	int nextParameter=1; //metemos una direccion para erspetar el orden en el que iran en la pila
	for (String name : fe.getParameters()){
		SymbolParameter symbol = (SymbolParameter) sTable.getSymbol(name);
		symbol.setAddress(-nextParameter);
		nextParameter+=1;
	}

	FuncionS fs=new FuncionS(fe.getParameters(), fa.getReturnType());
	if (fa.hasReturn())	
		fs.setHasReturn();
	fs.setIntermediateCode(fa.getIntermediateCode());
	scopeManager.closeScope();	 
	RESULT=fs;

:}
|CBRACKET OBRACE funcionA:fa  CBRACE
{:
	FuncionS fs=new FuncionS(fa.getReturnType()); //establece tipo retorno
	if (fa.hasReturn())	
		fs.setHasReturn();
	fs.setIntermediateCode(fa.getIntermediateCode());
	scopeManager.closeScope(); 
	RESULT=fs;

:};


funcionA ::= funcionB:fb funcionC:fc funcionD:fd //sentencias
{: 
	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	FuncionA fa =new FuncionA(fd.getReturnType());//establece tipo de retorno
	if (fd.hasReturn())	
		fa.setHasReturn();
	//fa.setIntermediateCode(fd.getIntermediateCode());
	cb.addQuadruples(fc.getIntermediateCode());
	cb.addQuadruples(fd.getIntermediateCode());
	fa.setIntermediateCode(cb.create());

	RESULT=fa;
:};

funcionB ::= tipo:ti funcionB:fb
{:
	fb.add(ti);
	RESULT=fb;
:} | {:
	ArrayList<Tipo> fb = new ArrayList<Tipo>();
	RESULT=fb;
:};

funcionC ::= funcionC:fc variable:var
{:
 	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruples(fc.getIntermediateCode());
	cb.addQuadruples(var.getIntermediateCode());
	System.out.println("En funcion");
	System.out.println(var.getIntermediateCode());
	fc.setIntermediateCode(cb.create());
	System.out.println("En funcion TOTAL");
	System.out.println(fc.getIntermediateCode());

	RESULT=fc;
:} | {:
	NonTerminalGeneric fc = new NonTerminalGeneric();
	RESULT=fc;
:};


funcionD ::= sentencia:sen funcionD:fd
{:
	ScopeIF scope = scopeManager.getCurrentScope();		
	SymbolTableIF sTable = scope.getSymbolTable();
	
	if (sen.isReturn()) //Si una de las sentencias es un return, poner el tipo
		fd.setReturnType(sen.getReturnType());

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruples(sen.getIntermediateCode()); //coger intermediate code y pasarselo a funcionD
	cb.addQuadruples(fd.getIntermediateCode());
	fd.setIntermediateCode(cb.create());

	RESULT=fd;
:} | {:

	ScopeIF scope = scopeManager.getCurrentScope();		
	FuncionD fd = new FuncionD(scope); //para declarar tipo void por defecto
	RESULT=fd;
:};

//Declaracion de parametros funcion			
funcionE ::= INT ID:id COMMA funcionE:fe 
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();			
	SymbolTableIF sTable = scope.getSymbolTable();
	sTable.addSymbol(name, new SymbolParameter(scope, name, new TypeSimpleInteger(scope), 0));
	
	fe.add(name);
	RESULT=fe;
:}
| INT ID:id 
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();			
	SymbolTableIF sTable = scope.getSymbolTable();
	sTable.addSymbol(name, new SymbolParameter(scope, name, new TypeSimpleInteger(scope), 0));
	
	FuncionE fe = new FuncionE(name);
	RESULT=fe;
:};		



/************************************
//Declaracion main
************************************/

// void main(){cosas} sin argumentos
main ::= VOID MAIN:mn
{: 
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF sTable = scope.getSymbolTable();
	TypeTableIF tTable = scope.getTypeTable();

	if(sTable.containsSymbol("main"))
		semanticErrorManager.semanticFatalError("No pueden existir dos funciones main " + mn.getLine() + mn.getColumn());
	TypeIF tipoVoid = new TypeSimpleVoid(scope);
	sTable.addSymbol("main",new SymbolProcedure(scope, "main", tipoVoid, 0));
	
	scopeManager.openScope("main");
	
:}
OBRACKET CBRACKET OBRACE mainA:ma CBRACE
{: 	
	ScopeIF scope = scopeManager.getCurrentScope();
	NonTerminalGeneric m = new NonTerminalGeneric();
	LabelIF label = new LabelFactory().create("MAIN");
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruple("INL",label); // uno por funcion, para test
	//cb.addQuadruple("BR", "L_L_GLOBAL");
	Variable fun = new Variable("main", scope);
	cb.addQuadruple("CALL", fun, 0); // debe ir directo a main
	// funciones iniciales de main
	
	cb.addQuadruples(ma.getIntermediateCode());
	m.setIntermediateCode(cb.create());
	//m.setIntermediateCode(ma.getIntermediateCode());
	RESULT= m;
	scopeManager.closeScope(); 
:};


mainA ::= mainB:mb mainC:mc mainD:md
{: 
	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	NonTerminalGeneric ma= new NonTerminalGeneric();
	cb.addQuadruples(mc.getIntermediateCode());
	cb.addQuadruples(md.getIntermediateCode());
	ma.setIntermediateCode(cb.create());
	RESULT= ma; 
:};

mainB ::= tipo:ti mainB:mb 
{::} | {::};

mainC ::= mainC:mc variable:var
{: //WIP puede que tenga que invertir el orden
	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruples(mc.getIntermediateCode());
	cb.addQuadruples(var.getIntermediateCode());
	System.out.println("En main");
	System.out.println(var.getIntermediateCode());
	mc.setIntermediateCode(cb.create());
	
	RESULT=mc;
:} | {:
	NonTerminalGeneric mc= new NonTerminalGeneric(); 
	RESULT=mc;
:};
						
mainD ::= sentencia:sen mainD:md 
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruples(sen.getIntermediateCode());
	cb.addQuadruples(md.getIntermediateCode());
	md.setIntermediateCode(cb.create());
	RESULT=md;
:} | {: 
	NonTerminalGeneric md = new NonTerminalGeneric();
	RESULT= md;
:};

	
